name: My Deploy
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  # debug:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: recupération du code avec une action checkoutv4
  #       uses: actions/checkout@v4
  #     - name: afficher le dossier d'exécution avec pwd
  #       run: pwd
  #     - name: Lister les fichiers et dossiers enfants avec ls-la
  #       run: ls -la
  # pylint:
  #   needs: debug
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Récupération du code
  #       uses: actions/checkout@v4
  #     - name: Installer Python
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: '3.12'
  #     - name: Restaurer le cache pip
  #       uses: actions/cache@v3
  #       with:
  #         path: ~/.cache/pip
  #         key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
  #         restore-keys: |
  #           ${{ runner.os }}-pip-
  #     - name: Install pylint et les requirements
  #       run: |
  #         python -m pip install --upgrade pip
  #         pip install pylint
  #         pip install -r app/requirements.txt
  #     - name: Lancer pylint
  #       run: |
  #         pylint app/app.py --fail-under=7
  # unit-tests:
  #   needs: pylint
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Récupération du code avec une GitHub action
  #       uses: actions/checkout@v4
  #     - name: Installer Python avec une action github
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: '3.12'
  #     - name: Restaurer le cache pip
  #       uses: actions/cache@v3
  #       with:
  #         path: ~/.cache/pip
  #         key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
  #         restore-keys: |
  #           ${{ runner.os }}-pip-
  #     - name: Installer les dépendances
  #       run: |
  #         python -m pip install --upgrade pip
  #         pip install -r app/requirements.txt
  #     - name: Exécuter les tests unitaires
  #       run: pytest -vv tests_unitaires
  deploy_job:
    # needs: unit-tests
    runs-on: ubuntu-latest
    steps:
      - name: Récupérer le code
        uses: actions/checkout@v4
      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: pierre.defourneaux@gmail.com
          password: dckr_pat_nbP66FNxUhGmvzixmYYt__5m6dg
      - name: Build and start containers
        run: docker compose up --build -d
        #le -d (détaché) est nécessaire, sinon l’action bloque car les conteneurs restent au premier plan.
        env:
          POSTGRES_PASSWORD: AzertyuioP1!
      - name: Show running containers
        run: |
          echo "Conteneurs :"
          docker ps -a
# Attention : par défaut, les jobs GitHub Actions tournent dans des runners séparés. Donc les conteneurs lancés dans deploy_job ne sont pas accessibles dans integration-tests.
# Deux solutions :
# Garder tout (deploy + tests d’intégration) dans un seul job.
# Utiliser un service container GitHub Actions pour la DB/webapp.
  integration-tests:
    needs: deploy_job
    runs-on: ubuntu-latest
    steps:
      # - name: Récupération du code avec une GitHub action
      #   uses: actions/checkout@v4
      # - name: Installer Python avec une action github
      #   uses: actions/setup-python@v5
      #   with:
      #     python-version: '3.12'
      # - name: Restaurer le cache pip
      #   uses: actions/cache@v3
      #   with:
      #     path: ~/.cache/pip
          # key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
      #     restore-keys: |
      #       ${{ runner.os }}-pip-
      # - name: Installer les dépendances
        # run: |
          # python -m pip install --upgrade pip
          # pip install -r app/requirements.txt
      - name: Exécuter les tests d'intégration
        # run: pytest -vv /_integration_tests
        run: echo "test d'intégration ici..."